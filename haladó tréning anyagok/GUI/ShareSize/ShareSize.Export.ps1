#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: 5d2a88c0-a60f-4199-ba13-e1da68253108
# Source File: ShareSize.psproj
#------------------------------------------------------------------------
#region Project Recovery Data (DO NOT MODIFY)
<#RecoveryData:
AgIAAB+LCAAAAAAABACNkV1LwzAUhu8H+w8l912azY0O0ly4OfHCD9bhrZy1pxpJm5K04vz1pjYd
HYJ4+STveV5ywveY6Q80py00IKaTIOBPRr9j1vyAw2c0VupKsBnjdAB/t5MK77Zimc8hjrMohFVU
hFdsvQ6PwBYhshxW8Xy5YFHMqQ/7Ud9yONUoIk7HOMi1yl1dQMdt1oPHYI8FGqwyfIASE0KC61aq
PCEREWkDpmnrWW1tX/736AaUCu9BVjttypfaFmPXcO5kxb9lt0ofQTkVG6mCjS5LqPKbzwarbpcJ
OZgWiejT1jWwi4Ye+nef99TTo5GvsgLVBbpekb6BwVR+obPULsnpr8h0wunFn38Dr0EFVAICAAA=#>
#endregion
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2015 v4.2.95
     Generated on:       2015.12.06. 13:21
     Generated by:       Administrator
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2015
#>


#region Source: Startup.pss
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
SwQAAB+LCAAAAAAABAC9lEtLAzEQgO+C/yH0vOzD7boWsgtS6UXQ4kr1mk1nS2geZZK07L93W0sV
PYiFhlwyEzIfH8MMfQFutoD9A3OMDBcrjK5GN6P6+ooQ+oxiJTSTMyHhiSmoG8fQ+U28sZYmv14P
f+6tBdVKAfYQf2X6WlluUIo2IosjaRyn+xORqZfOI1QavEMmIzL3Qw3+CP2rWYOu2rJkBS9us0k+
hvRuQpNT1Z+UprcOVAhG/Cb00uxsPDOobBDivk9hQMh2Qq/OYaV5V3Rll2XLImU5+5v1rmQYJ4HA
ncG+AdwKDme17N92U4MQRO9oNUczqF3A7RR+zjZNvi+P+gNBqg7+SwQAAA==#>
#endregion
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use: 
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
		
	#--------------------------------------------------------------------------
	#TODO: Add initialization script here (Load modules and check requirements)
	
	
	#--------------------------------------------------------------------------
	
	if((Call-MainForm_psf) -eq 'OK')
	{
		
	}
	
	$global:ExitCode = 0 #Set the exit code for the Packager
}






#endregion Source: Startup.pss

#region Source: MainForm.psf
function Call-MainForm_psf
{
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
nREAAB+LCAAAAAAABADNWF1v2jAUfZ+0/5DlGUHCNxJEarO1ndZuaGHd3irjXIqHEyPboc1+/eyE
UCjtcCigCQnh5Fyfe+85/hD974DZAnj6EUlkqR+CsHhg123v/TvL6n/j5J7EiF4QCl9RBN4NIvEF
41F1Lib92tbrPGj8G7C0ZDqHgR2kQkJU/UnikD2Iqo7NvyvWS68q1u0yh2bV0Z+K5SdUJhwGMSSS
I1qxhsmYEvwF0hGbQTwYdzqohVttt9dogtPt2VasUhnYRaq2haeEhlxBbZ/FkjMq8vJUrkPO5sBl
uozxKYFYBuQP2F6r2a5YjW6zXytArwTpyu1VZ3bCA4m4HDJBpCrT9nxFCDzAHCDeGTuCR2l7wRRx
0EmK7YBPCzXfEn3NUPiU2J0e9msZoEDvlsqfAp6ds8ejyzUkUHD9S7HtnlwzjPJWNjtuxar3thV7
TbM1ToOY3BbaFXUTihEaf45DeFROMkFnyqqEDLA/BNwSkSAayJTCOcIzn1HGbW/Ek+14tUwzlc01
P0+kZPHRFfeVjWXOta/i9W5DK27S4FzxNU5jxd12S5E0SkluZJBM8iyjg4v+bCdQ+xqebVR/lz16
th38r065ZG+zSbddziUFn7lFmt3SFjFCZxa5ZB9OZJCi8MO4Q98pLjkJbwk8HN0jQh+KQqtRyiSq
R0kUXwEKVSJXQO6n2fF/w0Il61kimR4ZdP/JbK4yW7tn7LVV3sZmazn6mHPqpdz2InrDAWuNuGGJ
gKUlVvndvYx4q0mu0Rjo0d1BNYvPonmiLlv7biNudiE0VnaD03wrcVSZbrkLhmt+2ryWTnnh9ISn
uBjit6pWryvZTFZLLhsuq1ijp+8HTinFttEbAmwOzoSASPUKRIFdPkm9SGDGKRkfoN/92mrW5yy5
wqfgOLiLdjPqU+o0RBw9kPh+Hy6nMWlNOhPXDVsOaqDdXL8iepqaCFc2ZTwNgC8Ihr0kK12dzzic
pLxlVWqpqtKOUNtqmK/tfm397xjvL2EG5VOdEQAA#>
#endregion
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$MainForm = New-Object 'System.Windows.Forms.Form'
	$PieCheckBox = New-Object 'System.Windows.Forms.CheckBox'
	$ChartButton = New-Object 'System.Windows.Forms.Button'
	$GoButton = New-Object 'System.Windows.Forms.Button'
	$sharesize = New-Object 'System.Windows.Forms.DataGridView'
	$labelComputer = New-Object 'System.Windows.Forms.Label'
	$computer = New-Object 'System.Windows.Forms.TextBox'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$MainForm_Load={
	#TODO: Initialize Form Controls here
	
	}
	
	#region Control Helper Functions
	function Load-DataGridView
	{
		<#
		.SYNOPSIS
			This functions helps you load items into a DataGridView.
	
		.DESCRIPTION
			Use this function to dynamically load items into the DataGridView control.
	
		.PARAMETER  DataGridView
			The DataGridView control you want to add items to.
	
		.PARAMETER  Item
			The object or objects you wish to load into the DataGridView's items collection.
		
		.PARAMETER  DataMember
			Sets the name of the list or table in the data source for which the DataGridView is displaying data.
	
		#>
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			[System.Windows.Forms.DataGridView]$DataGridView,
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			$Item,
		    [Parameter(Mandatory=$false)]
			[string]$DataMember
		)
		$DataGridView.SuspendLayout()
		$DataGridView.DataMember = $DataMember
		
		if ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
		{
			$DataGridView.DataSource = $Item
		}
		else
		{
			$array = New-Object System.Collections.ArrayList
			
			if ($Item -is [System.Collections.IList])
			{
				$array.AddRange($Item)
			}
			else
			{	
				$array.Add($Item)	
			}
			$DataGridView.DataSource = $array
		}
		
		$DataGridView.ResumeLayout()
	}
	
	function ConvertTo-DataTable
	{
		<#
			.SYNOPSIS
				Converts objects into a DataTable.
		
			.DESCRIPTION
				Converts objects into a DataTable, which are used for DataBinding.
		
			.PARAMETER  InputObject
				The input to convert into a DataTable.
		
			.PARAMETER  Table
				The DataTable you wish to load the input into.
		
			.PARAMETER RetainColumns
				This switch tells the function to keep the DataTable's existing columns.
			
			.PARAMETER FilterWMIProperties
				This switch removes WMI properties that start with an underline.
		
			.EXAMPLE
				$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
		#>
		[OutputType([System.Data.DataTable])]
		param(
		[ValidateNotNull()]
		$InputObject, 
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterWMIProperties)
		
		if($Table -eq $null)
		{
			$Table = New-Object System.Data.DataTable
		}
	
		if($InputObject-is [System.Data.DataTable])
		{
			$Table = $InputObject
		}
		else
		{
			if(-not $RetainColumns -or $Table.Columns.Count -eq 0)
			{
				#Clear out the Table Contents
				$Table.Clear()
	
				if($InputObject -eq $null){ return } #Empty Data
				
				$object = $null
				#find the first non null value
				foreach($item in $InputObject)
				{
					if($item -ne $null)
					{
						$object = $item
						break	
					}
				}
	
				if($object -eq $null) { return } #All null then empty
				
				#Get all the properties in order to create the columns
				foreach ($prop in $object.PSObject.Get_Properties())
				{
					if(-not $FilterWMIProperties -or -not $prop.Name.StartsWith('__'))#filter out WMI properties
					{
						#Get the type from the Definition string
						$type = $null
						
						if($prop.Value -ne $null)
						{
							try{ $type = $prop.Value.GetType() } catch {}
						}
	
						if($type -ne $null) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
						{
			      			[void]$table.Columns.Add($prop.Name, $type) 
						}
						else #Type info not found
						{ 
							[void]$table.Columns.Add($prop.Name) 	
						}
					}
			    }
				
				if($object -is [System.Data.DataRow])
				{
					foreach($item in $InputObject)
					{	
						$Table.Rows.Add($item)
					}
					return  @(,$Table)
				}
			}
			else
			{
				$Table.Rows.Clear()	
			}
			
			foreach($item in $InputObject)
			{		
				$row = $table.NewRow()
				
				if($item)
				{
					foreach ($prop in $item.PSObject.Get_Properties())
					{
						if($table.Columns.Contains($prop.Name))
						{
							$row.Item($prop.Name) = $prop.Value
						}
					}
				}
				[void]$table.Rows.Add($row)
			}
		}
	
		return @(,$Table)	
	}
	#endregion
	
	$GoButton_Click = {
		$DataTable = ConvertTo-DataTable -InputObject (Get-ShareSizes $computer.Text)
		Load-DataGridView -DataGridView $sharesize -Item $DataTable
		
	}
	
	$sharesize_ColumnHeaderMouseClick=[System.Windows.Forms.DataGridViewCellMouseEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellMouseEventArgs]
		if ($datagridview1.DataSource -is [System.Data.DataTable])
		{
			$column = $datagridview1.Columns[$_.ColumnIndex]
			$direction = [System.ComponentModel.ListSortDirection]::Ascending
			
			if ($column.HeaderCell.SortGlyphDirection -eq 'Descending')
			{
				$direction = [System.ComponentModel.ListSortDirection]::Descending
			}
			
			$datagridview1.Sort($datagridview1.Columns[$_.ColumnIndex], $direction)
		}
		
	}
	
	$ChartButton_Click = {
		if ($PieCheckBox.Checked)
		{ Get-ShareSizesChart $computer.Text -Pie }
		else
		{ Get-ShareSizesChart $computer.Text }
		
	}
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$MainForm.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_PieCheckBox = $PieCheckBox.Checked
		$script:MainForm_sharesize = $sharesize.SelectedCells
		$script:MainForm_computer = $computer.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$ChartButton.remove_Click($ChartButton_Click)
			$GoButton.remove_Click($GoButton_Click)
			$sharesize.remove_ColumnHeaderMouseClick($sharesize_ColumnHeaderMouseClick)
			$MainForm.remove_Load($MainForm_Load)
			$MainForm.remove_Load($Form_StateCorrection_Load)
			$MainForm.remove_Closing($Form_StoreValues_Closing)
			$MainForm.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$MainForm.SuspendLayout()
	#
	# MainForm
	#
	$MainForm.Controls.Add($PieCheckBox)
	$MainForm.Controls.Add($ChartButton)
	$MainForm.Controls.Add($GoButton)
	$MainForm.Controls.Add($sharesize)
	$MainForm.Controls.Add($labelComputer)
	$MainForm.Controls.Add($computer)
	$MainForm.ClientSize = '546, 384'
	$MainForm.Name = 'MainForm'
	$MainForm.StartPosition = 'CenterScreen'
	$MainForm.Text = 'ShareSizes'
	$MainForm.add_Load($MainForm_Load)
	#
	# PieCheckBox
	#
	$PieCheckBox.Location = '471, 294'
	$PieCheckBox.Name = 'PieCheckBox'
	$PieCheckBox.Size = '46, 24'
	$PieCheckBox.TabIndex = 5
	$PieCheckBox.Text = 'Pie'
	$PieCheckBox.UseVisualStyleBackColor = $True
	#
	# ChartButton
	#
	$ChartButton.Location = '283, 295'
	$ChartButton.Name = 'ChartButton'
	$ChartButton.Size = '165, 23'
	$ChartButton.TabIndex = 4
	$ChartButton.Text = 'Chart'
	$ChartButton.UseVisualStyleBackColor = $True
	$ChartButton.add_Click($ChartButton_Click)
	#
	# GoButton
	#
	$GoButton.Location = '86, 295'
	$GoButton.Name = 'GoButton'
	$GoButton.Size = '148, 23'
	$GoButton.TabIndex = 3
	$GoButton.Text = 'Go!'
	$GoButton.UseVisualStyleBackColor = $True
	$GoButton.add_Click($GoButton_Click)
	#
	# sharesize
	#
	$sharesize.ColumnHeadersHeightSizeMode = 'AutoSize'
	$sharesize.Location = '16, 69'
	$sharesize.Name = 'sharesize'
	$sharesize.Size = '501, 202'
	$sharesize.TabIndex = 2
	$sharesize.add_ColumnHeaderMouseClick($sharesize_ColumnHeaderMouseClick)
	#
	# labelComputer
	#
	$labelComputer.Location = '16, 38'
	$labelComputer.Name = 'labelComputer'
	$labelComputer.Size = '100, 14'
	$labelComputer.TabIndex = 1
	$labelComputer.Text = 'Computer'
	#
	# computer
	#
	$computer.Location = '122, 32'
	$computer.Name = 'computer'
	$computer.Size = '395, 20'
	$computer.TabIndex = 0
	$MainForm.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $MainForm.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$MainForm.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$MainForm.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$MainForm.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $MainForm.ShowDialog()

}
#endregion Source: MainForm.psf

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($hostinvocation -ne $null)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	#-----------------------------------------
	# Private Functions
	#-----------------------------------------
	Function Get-ShareSize
	{
		PARAM ([Parameter(Mandatory = $true, Position = 0, valueFromPipeline = $true)]
			[string]$Share)
		PROCESS
		{
			$entries = Get-ChildItem -recurse $Share
			$dirs = ($entries | Where-Object { $_ -is [System.IO.DirectoryInfo] })
			$files = ($entries | Where-Object { $_ -is [System.IO.FileInfo] })
			$sum = 0
			for ($i = 0; $i -lt $files.count; $i++)
			{
				$sum += $files[$i].Length
			}
			return $sum
		}
	}
	
	function Chart-Data
	{
		PARAM (
			[System.Collections.ArrayList]$Data = @(@{ Name = "London"; Value = 7556900 },
			@{ Name = "Berlin"; Value = 3429900 },
			@{ Name = "Madrid"; Value = 3213271 },
			@{ Name = "Rome"; Value = 2726539 },
			@{ Name = "Paris"; Value = 2188500 }),
			[System.String]$ChartTitle = "Top 5 European Cities by Population",
			[System.String]$AxisXTitle = "European Cities",
			[System.String]$AxisYTitle = "Population",
			[switch]$pie
		)
		# load the appropriate assemblies 
		[void][Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
		[void][Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms.DataVisualization")
		# create chart object 
		$Chart = New-object System.Windows.Forms.DataVisualization.Charting.Chart
		$Chart.Width = 500
		$Chart.Height = 450
		$Chart.Left = 40
		$Chart.Top = 30
		# create a chartarea to draw on and add to chart 
		$ChartArea = New-Object System.Windows.Forms.DataVisualization.Charting.ChartArea
		$Chart.ChartAreas.Add($ChartArea)
		# add data to chart 
		[void]$Chart.Series.Add("Data")
		$Chart.Series["Data"].Points.DataBindXY($($Data | %{ $_.Name }), $($data | %{ $_.Value }))
		if (!$pie)
		{
			#$Chart.Series["Data"].Sort([System.Windows.Forms.DataVisualization.Charting.PointSortOrder]::Descending, "Y")
			# add title and axes labels 
			[void]$Chart.Titles.Add($ChartTitle)
			$ChartArea.AxisX.Title = $AxisXTitle
			$ChartArea.AxisY.Title = $AxisYTitle
			# Find point with max/min values and change their colour 
			$maxValuePoint = $Chart.Series["Data"].Points.FindMaxByValue()
			$maxValuePoint.Color = [System.Drawing.Color]::Red
			$minValuePoint = $Chart.Series["Data"].Points.FindMinByValue()
			$minValuePoint.Color = [System.Drawing.Color]::Green
			# make bars into 3d cylinders 
			$Chart.Series["Data"]["DrawingStyle"] = "Cylinder"
		}
		else
		{
			# set chart type 
			$Chart.Series["Data"].ChartType = [System.Windows.Forms.DataVisualization.Charting.SeriesChartType]::Pie
			# set chart options 
			$Chart.Series["Data"]["PieLabelStyle"] = "Outside"
			$Chart.Series["Data"]["PieLineColor"] = "Black"
			$Chart.Series["Data"]["PieDrawingStyle"] = "Concave"
			($Chart.Series["Data"].Points.FindMaxByValue())["Exploded"] = $true
		}
		# change chart area colour 
		$Chart.BackColor = [System.Drawing.Color]::Transparent
		# add a save button 
		$SaveButton = New-Object Windows.Forms.Button
		$SaveButton.Text = "Save"
		$SaveButton.Top = 500
		$SaveButton.Left = 450
		$SaveButton.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right
		$SaveButton.add_click({ $Chart.SaveImage($Env:USERPROFILE + "\Desktop\Chart.png", "PNG") })
		# display the chart on a form 
		$Chart.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right -bor
		[System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Left
		$Form = New-Object Windows.Forms.Form
		$Form.Text = "PowerShell Chart"
		$Form.Width = 600
		$Form.Height = 600
		$Form.controls.add($Chart)
		$Form.controls.add($SaveButton)
		$Form.Add_Shown({ $Form.Activate() })
		$Form.ShowDialog()
	}
	
	function Get-ChartData
	{
		PARAM ([Parameter(Mandatory = $true, Position = 0, valueFromPipeline = $true)]
			[System.Object[]]$InputObject,
			[Parameter(Mandatory = $true, Position = 1)]
			[System.String]$key,
			[Parameter(Mandatory = $true, Position = 2)]
			[System.String]$value)
		BEGIN { $result = New-Object system.collections.arraylist }
		PROCESS
		{
			foreach ($item in $InputObject)
			{ $result.Add(@{ Name = $item.$key; Value = $item.$value }) > $null }
		}
		END { return $result }
	}
	
	#-----------------------------------------
	# Module Functions
	#-----------------------------------------
	Function Get-Shares
	{
	<#
	   .Synopsis
	    A paraméterként megadott számítógép megosztásainak listázása 
	   .Description
	    A Get-Shares függvény visszaadja a paraméterként megadott számítógép megosztásait egy objektumtömbben
	   .Example
	    Get-Shares localhost
	    A helyi gép megosztásainak listázása
	    .Example
	    "Server","localhost" | Get-Shares
	    A felsorolt gépek megosztásainak listázása
	    .Example
	    Get-Content C:\servers.txt | Get-Shares
	    A servers.txt állományban felsorolt gépek megosztásainak listázása
	   .Parameter Computer
	    A számítógép neve, aminek a megosztásait listázni szeretnénk
	   .Inputs
	    [String]
	   .OutPuts
	    [Object[]]
	   .Notes
	    2.0-s Powershell verziótól
	   .Link
	    http://powershell.org
	#>
		[CmdletBinding(SupportsShouldProcess)]
		PARAM ([Parameter(Mandatory = $true, Position = 0, valueFromPipeline = $true)]
			[string]$Computer)
		PROCESS
		{
			try
			{
				$shares = @()
				$shares = (Get-WmiObject -ComputerName $Computer -Class Win32_Share -ErrorAction Stop) -notmatch "[a-z0-9]*\$"
				return $shares
			}
			catch [System.Runtime.InteropServices.COMException]
			{
				Write-Output "Nem lehet kapcsolódni a $Computer nevű számítógéphez"
			}
			catch
			{
				Write-Output "Ismeretlen hiba történt"
			}
		}
	}
	
	Function Get-ShareSizes
	{
	<#
	   .Synopsis
	    A paraméterként megadott számítógép megosztásainak listázása név és méret visszaadásával 
	   .Description
	    A Get-ShareSizes függvény visszaadja a paraméterként megadott számítógép megosztásainak nevét 
	    és méretét egy objektumtömbben
	   .Example
	    Get-ShareSizes localhost
	    A helyi gép megosztásainak neve és mérete
	    .Example
	    "Server","localhost" | Get-Shares
	    A felsorolt gépek megosztásainak neve és mérete
	    .Example
	    Get-Content C:\servers.txt | Get-Shares
	    A servers.txt állományban felsorolt gépek megosztásainak neve és mérete
	   .Parameter Computer
	    A számítógép neve, aminek a megosztásait listázni szeretnénk
	   .Inputs
	    [String]
	   .OutPuts
	    [Object[]]
	   .Notes
	    2.0-s Powershell verziótól
	   .Link
	    http://powershell.org
	#>
		[CmdletBinding(SupportsShouldProcess)]
		PARAM ([Parameter(Mandatory = $true, Position = 0, valueFromPipeline = $true)]
			[string]$Computer)
		PROCESS
		{
			try
			{
				$valid = Get-WmiObject -ComputerName $Computer –Class Win32_OperatingSystem -ErrorAction Stop
				$shares = Get-Shares $Computer
				$Target = @()
				foreach ($dir in $shares)
				{
					$size = $dir.Name | % { [math]::Round(((Get-ShareSize ('\\' + $Computer + '\' + $_))/1Mb), 2) }
					$TargetProperties = @{ Name = $dir.Name; Size = $Size }
					$TargetObject = New-Object PSObject –Property $TargetProperties
					$Target += $TargetObject
				}
				return $Target
			}
			catch [System.Runtime.InteropServices.COMException]
			{
				Write-Output "Nem lehet kapcsolódni a $Computer nevű számítógéphez"
			}
			catch
			{
				Write-Output "Ismeretlen hiba történt"
			}
		}
	}
	
	function Get-ShareSizesChart
	{
	<#
	   .Synopsis
	    A paraméterként megadott számítógép megosztásainak listázása diagram formátumban 
	   .Description
	    A Get-ShareSizesChart függvény diagramként kirajzolja a paraméterként megadott számítógép megosztásainak nevét 
	    és méretét
	   .Example
	    Get-ShareSizesChart localhost
	    A helyi gép megosztásainak neve és mérete oszlopdiagram formátumban
	   .Example
	    Get-ShareSizesChart localhost -Pie
	    A helyi gép megosztásainak neve és mérete tortadiagram formátumban
	   .Parameter Computer
	    A számítógép neve, aminek a megosztásait listázni szeretnénk
	   .Parameter Pie
	    Az alapértelmezett oszlopdiagramformátumot állítja át tortadiagram formátumra 	
	   .Inputs
	    [String]
	    [Switch] 
	   .OutPuts
	    [System.Windows.Forms.DataVisualization.Charting.Chart]
	   .Notes
	    2.0-s Powershell verziótól
	   .Link
	    http://powershell.org
	#>
		[CmdletBinding(SupportsShouldProcess)]
		PARAM ([Parameter(Mandatory = $true, Position = 0)]
			[string]$Computer,
			[switch]$pie)
		
		try
		{
			$valid = Get-WmiObject -ComputerName $Computer –Class Win32_OperatingSystem -ErrorAction Stop
			$Chartdata = Get-ShareSizes $Computer | Get-ChartData -key Name -value Size
			if (!$pie)
			{ Chart-Data -Data $Chartdata -ChartTitle "Processes" -AxisXTitle "Shares" -AxisYTitle "Size" }
			else
			{ Chart-Data -Data $Chartdata -ChartTitle "Processes" -AxisXTitle "Shares" -AxisYTitle "Size" -Pie }
		}
		catch [System.Runtime.InteropServices.COMException]
		{
			Write-Output "Nem lehet kapcsolódnia a $Computer nevű számítógéphez"
		}
		catch
		{
			Write-Output "Ismeretlen hiba történt"
		}
	}
	
	
	
	
	#endregion Source: Globals.ps1

#Start the application
Main ($CommandLine)
